# О структуре проекта и зависимостях

Проект разделен на части: 
1) ядро проекта - https://github.com/alfa-laboratory/colibri-ui
2) настроки под конкретный проект - этот проект
    * В папке main у нас находятся настройки которые от проекта к проекту мало меняются. Они настраивают базовые вещи типа таймаутов и репортеров.
    * В папке test - собственно стартеры проекта для ios и android и настройки для конкретнной платформы
    * В тестовых ресурсах описаны сценарии, экраны, телефоны, циклы и пользователи

##### Что умеем кроме тестирования
На текущий момент проект умеет:
1) сам запускать себе ноду аппиума на сервере CI 
2) писать логи в аллюр репортер
3) интегрирован с Report Portal и может писать логи туда
4) умеет фильтровать сценарии и запускать только тот объем который нас интересует в данный момент

## Сценарии (story)

Верхнеуровневые сценарии описаны на русском языке с использованием gherkin спецификаций.
Для BDD мы использовали jbehave.

##### Как мы понимаем ключевые слова из сценариев
* given - предусловия для сценариев, например проверить что мы находимся на главном экране и если это не так, попробовать вернуться на него
* when - различные действия над приложением, например нажать кнопку/заполнить поле
* then - проверки. Например убедиться что на экране ровно 3 элемента нужного типа или что надпись на экране содержит интересующее нас значение

### Состав сценария
Блок Meta мы используем чтоб указать метки тестовых циклов в которых будет участвовать данный сценарий. 
Например:
```
Meta:
@regressCycle
@debugMode
```

Блок Narrative - Описание сценария в свободной форме
В этом же блоке можут быть указаны конструкции по управлению жизненным циклом сценария
Например:
```
   Narrative:
   TESTMODEL-1234 - Успешное создание шаблона электронных денег
   
   Lifecycle:
   Before:
   Given вернуться на "Главный экран"
``` 
В примере указан вариант с жизненным циклом. Сначала мы делаем описание, в нашем случае это номер тест-кейса в тестовой модели с названием
Затем в подблоке `Lifecycle` указываем что перед сценарием должен быть выполнен шаг возврата на главный экран

Далее идет сам сценарий как набор шагов given-when-then. Сценарий начинается со слова `Scenario`
Например:
```
Scenario: Успешное создание шаблона электронных денег
```

После набора шагов может идти таблица со значениями параметризации. Более подробно ниже.
Например:
``` 
Examples:
|type |
|PDF  |
|Excel|
```
С подобной таблицей после сценария тест будет пройден 2 раза, а значение `type` будет в них отличаться. 
Первый раз тест пройдет со значением `1C`, а второй - `Excel`

#### Подстановки в сценариях

В сценарии возможно использование 3 типов подстановок
1) Простая подстановка - указывает в явном виде имя элемента из описания экрана. Значение будет взято из папки pages
```When выполнено нажатие на "Войти"``` 
2) Подстановка на уровне сценария из блока Examples. Такая подстановака указывается в угловых скобках
```When выполнено нажатие на "<type>"```
3) Подстановка данных пользователя. Такая подстановака указывается со знаками `#` и значение будет взято из папки users
```When поле "Логин" заполняется значением "#userName#"```

## Экраны (pages)

Экраны представляют собой описание элементов в виде csv-таблицы
В файлах с описанием экранов есть часть служебных данных. Они занимают первые 2 строки
В первой строке указано имя экрана, по которому мы обратимся к нему из сценария. Это имя указано в верхней левой ячейке (A1, если пользоваться различными просмотрщиками таблиц, например TableTools)
Во второй строке указаны имена столбцов. Они указывают какие варианты описания в какую ячейку писать. Создано для удобства описания экранов.
Далее с 3 строки идут элементы данного экрана со своими описаниями.

В зависимости от подходов к разработке приложений для андроида, есть возможность проводить навигацию не по именам экранов, а по их активити.
В случае использования активити, ее имя без указания корневого пакета пишется в ячейку С1 и в настройках окружения указывается флаг useActivity=true 
(Более подробно в блоке Environment) 

#### Описание элементов

В общем виде описание элемента на экране состоит из имени (столбец A), одного из 4 локаторов (столбцы B-E, для iOS их 5 - B-F) и признака специфичности (Flag is specific) в последнем столбце
Имя - это то имя, которое будет указано в сценарии для обращения к элементу. Например в ```When выполнено нажатие на "Войти"``` указан элемент `Войти`
Локаторы - это это значение которое будет передано аппиуму для поисков.
Flag is specific - если в этом столбце для элемента стоит true, значит при проверке ```Then загружена страница "Главный экран"``` будет запрошена страница с именем `Главный экран` и проверено что все элементы с указанным флагом есть на экрение.
В целом хватает 2-3 специфичных элементов
Локаторы могут содержать подстановки данных пользователя. Пример iOSNSPredicate с подстановкой: `type like 'XCUIElementTypeStaticText' and name like '#creditAccountRur#`. Значение `creditAccountRur` будет взято из описания пользователя

##### Локаторы (Android)

* Content-desc - если он уникален, почему бы не поиспользовать
* ResourceId - уникальный id элемента в проекте. Можно узнать его от разработчиков. Самый лучший вариант для поиска
* Text - видимый текст. Поиск по вхождению. Возможны проблемы с символами типа Й,Ё и тд
* XPath - самый медленный поиск, но если ничего больше не помогает, то приходится использовать его. Ограничения: не работает поиск по sibling-осям

##### Локаторы (iOS)

Те же что и для андроида, content-desk не обрабатывается
Добавлен iOSNSPredicate - локатор на уровне XCUITest (Шпаргалка по этим локаторам будет в полезностях)

## Пользователи (users)

Для некоторых проектов может появиться потребность работать с данными пользователя (Имя, телефон, номер счета и тд)
Все подобные данные можно вынести в отдельное описание в папку `users` Это простые properties файлы где ключом является значение между знаками `#` в сценарии или экране